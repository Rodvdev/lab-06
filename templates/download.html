{% extends "base.html" %}
{% block content %}
<div class="download-page">
  <div class="download-section">
    <h2 class="page-title">Descargar Video</h2>
    <p class="page-subtitle">YouTube 路 Instagram 路 TikTok 路 Facebook 路 Twitter/X y m谩s</p>

    <form class="download-form">
      <div class="input-group">
        <input 
          id="url" 
          name="url" 
          type="text" 
          placeholder="Pega la URL del video..." 
          required
          value=""
          autocomplete="off"
          autofocus
        >
      </div>

      <div class="quality-selector">
        <label for="quality">Calidad:</label>
        <select id="quality" name="quality">
          <option value="best">Mejor disponible</option>
          <option value="audio">Solo audio (MP3)</option>
        </select>
      </div>

      <!-- Selector de rango de tiempo -->
      <div id="time-range-selector" class="time-range-selector" style="display: none;">
        <div class="time-range-header">
          <label>
            <input type="checkbox" id="enable-time-range" />
            <span>Recortar video</span>
          </label>
        </div>
        
        <div id="time-range-controls" class="time-range-controls" style="display: none;">
          <div class="time-range-info">
            <span id="video-duration-display" class="video-duration-display"></span>
          </div>
          
          <div class="time-sliders">
            <div class="time-slider-group">
              <label for="start-time-slider">Inicio:</label>
              <input type="range" id="start-time-slider" min="0" max="0" value="0" step="1" />
              <input type="text" id="start-time-input" class="time-input" placeholder="0:00" />
            </div>
            
            <div class="time-slider-group">
              <label for="end-time-slider">Fin:</label>
              <input type="range" id="end-time-slider" min="0" max="0" value="0" step="1" />
              <input type="text" id="end-time-input" class="time-input" placeholder="0:00" />
            </div>
          </div>
          
          <div class="time-range-preview">
            <span>Rango seleccionado: </span>
            <span id="time-range-preview">0:00 - 0:00</span>
            <span id="time-range-duration">(0:00)</span>
          </div>
        </div>
      </div>

      <button type="submit" class="download-btn" id="download-btn">
        <span id="download-btn-text">Descargar</span>
      </button>
    </form>

    <!-- Plataforma detectada (mostrada din谩micamente) -->
    <div id="platform-detected" class="platform-detected" style="display: none;">
      <div class="platform-badge">
        <span id="platform-icon" class="platform-icon"></span>
        <span id="platform-name" class="platform-name"></span>
      </div>
    </div>

    <!-- Plataforma est谩tica (solo se muestra si no hay detecci贸n din谩mica) -->
    {% if platform %}
      <div id="platform-static" class="platform-detected">
        <div class="platform-badge">
          <span class="platform-icon">{{ platform.icon }}</span>
          <span class="platform-name">{{ platform.name }}</span>
        </div>
      </div>
    {% endif %}

    {% if error %}
      <div class="message error-message">
        <span>{{ error }}</span>
      </div>
    {% endif %}

    <!-- Barra de progreso -->
    <div id="progress-container" class="progress-container" style="display: none;">
      <div class="progress-card">
        <div class="progress-header">
          <h3 class="progress-title">Descargando...</h3>
          <span id="progress-percent" class="progress-percent">0%</span>
        </div>
        <div class="progress-bar-wrapper">
          <div id="progress-bar" class="progress-bar">
            <div id="progress-bar-fill" class="progress-bar-fill"></div>
          </div>
        </div>
        <p id="progress-message" class="progress-message">Iniciando descarga...</p>
      </div>
    </div>

    {% if video_info %}
      <div class="video-preview">
        <div class="video-info-card">
          {% if video_info.thumbnail %}
            <div class="video-thumbnail">
              <img src="{{ video_info.thumbnail }}" alt="Thumbnail" loading="lazy">
            </div>
          {% endif %}
          <div class="video-details">
            <h3 class="video-title">{{ video_info.title }}</h3>
            {% if video_info.uploader %}
              <p class="video-uploader">{{ video_info.uploader }}</p>
            {% endif %}
            {% if video_info.duration_formatted %}
              <p class="video-duration">{{ video_info.duration_formatted }}</p>
            {% endif %}
          </div>
        </div>
      </div>
    {% endif %}

    <!-- Resultado de descarga (mostrado din谩micamente) -->
    <div id="download-result" style="display: none;"></div>

    <!-- Lista de descargas disponibles -->
    <div id="downloads-list-section" class="downloads-list-section">
      <div class="downloads-header">
        <h3 class="downloads-title">Descargas Disponibles</h3>
        <button id="refresh-downloads" class="refresh-btn"> Actualizar</button>
      </div>
      <div id="downloads-list" class="downloads-list">
        <p class="loading-text">Cargando...</p>
      </div>
    </div>

    {% if file_ready %}
      <div class="download-success">
        <div class="success-card">
          <h3 class="success-title">Descarga completada</h3>
          <p class="success-filename">{{ filename }}</p>
          <a href="{{ url_for('serve_download', filename=filename) }}" class="download-link">
            Descargar archivo
          </a>
        </div>
      </div>
    {% endif %}
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const form = document.querySelector('.download-form');
  const urlInput = document.getElementById('url');
  const downloadBtn = document.getElementById('download-btn');
  const downloadBtnText = document.getElementById('download-btn-text');
  const progressContainer = document.getElementById('progress-container');
  const progressBarFill = document.getElementById('progress-bar-fill');
  const progressPercent = document.getElementById('progress-percent');
  const progressMessage = document.getElementById('progress-message');
  const downloadResult = document.getElementById('download-result');
  const platformDetected = document.getElementById('platform-detected');
  const platformStatic = document.getElementById('platform-static');
  const platformIcon = document.getElementById('platform-icon');
  const platformName = document.getElementById('platform-name');
  
  let progressInterval = null;
  let currentTaskId = null;
  let detectTimeout = null;

  // Funci贸n para ocultar ambos badges de plataforma
  function hidePlatformBadges() {
    if (platformDetected) platformDetected.style.display = 'none';
    if (platformStatic) platformStatic.style.display = 'none';
  }

  // Funci贸n para mostrar el badge din谩mico
  function showPlatformBadge(icon, name) {
    if (platformDetected && platformIcon && platformName) {
      platformIcon.textContent = icon;
      platformName.textContent = name;
      platformDetected.style.display = 'block';
      // Ocultar el badge est谩tico si existe
      if (platformStatic) platformStatic.style.display = 'none';
    }
  }

  // Funci贸n para actualizar el selector de calidad con formatos disponibles
  function updateQualitySelector(formats) {
    const qualitySelect = document.getElementById('quality');
    if (!qualitySelect) return;
    
    // Guardar el valor actual
    const currentValue = qualitySelect.value;
    
    // Limpiar opciones existentes
    qualitySelect.innerHTML = '';
    
    // Agregar formatos disponibles
    formats.forEach(format => {
      const option = document.createElement('option');
      option.value = format.value;
      option.textContent = format.label;
      qualitySelect.appendChild(option);
    });
    
    // Restaurar el valor anterior si existe, sino usar 'best'
    if (currentValue && Array.from(qualitySelect.options).some(opt => opt.value === currentValue)) {
      qualitySelect.value = currentValue;
    } else {
      qualitySelect.value = 'best';
    }
  }

  // Variables para el selector de tiempo
  let videoDurationSeconds = 0;
  const timeRangeSelector = document.getElementById('time-range-selector');
  const enableTimeRange = document.getElementById('enable-time-range');
  const timeRangeControls = document.getElementById('time-range-controls');
  const startTimeSlider = document.getElementById('start-time-slider');
  const endTimeSlider = document.getElementById('end-time-slider');
  const startTimeInput = document.getElementById('start-time-input');
  const endTimeInput = document.getElementById('end-time-input');
  const videoDurationDisplay = document.getElementById('video-duration-display');
  const timeRangePreview = document.getElementById('time-range-preview');
  const timeRangeDuration = document.getElementById('time-range-duration');

  // Convertir segundos a formato HH:MM:SS o MM:SS
  function secondsToTime(seconds) {
    const hrs = Math.floor(seconds / 3600);
    const mins = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    
    if (hrs > 0) {
      return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }

  // Convertir formato HH:MM:SS o MM:SS a segundos
  function timeToSeconds(timeStr) {
    const parts = timeStr.split(':').map(Number);
    if (parts.length === 2) {
      return parts[0] * 60 + parts[1];
    } else if (parts.length === 3) {
      return parts[0] * 3600 + parts[1] * 60 + parts[2];
    }
    return 0;
  }

  // Actualizar selector de tiempo con duraci贸n del video
  function updateTimeRangeSelector(duration, durationFormatted) {
    if (!timeRangeSelector) return;
    
    videoDurationSeconds = duration || 0;
    
    if (videoDurationSeconds > 0) {
      // Mostrar selector de tiempo
      timeRangeSelector.style.display = 'block';
      
      // Actualizar duraci贸n mostrada
      if (videoDurationDisplay) {
        videoDurationDisplay.textContent = `Duraci贸n total: ${durationFormatted || secondsToTime(videoDurationSeconds)}`;
      }
      
      // Configurar sliders
      if (startTimeSlider) {
        startTimeSlider.max = videoDurationSeconds;
        startTimeSlider.value = 0;
      }
      if (endTimeSlider) {
        endTimeSlider.max = videoDurationSeconds;
        endTimeSlider.value = videoDurationSeconds;
      }
      
      // Actualizar inputs
      if (startTimeInput) {
        startTimeInput.value = '0:00';
      }
      if (endTimeInput) {
        endTimeInput.value = secondsToTime(videoDurationSeconds);
      }
      
      // Actualizar preview
      updateTimeRangePreview();
    } else {
      timeRangeSelector.style.display = 'none';
    }
  }

  // Actualizar preview del rango de tiempo
  function updateTimeRangePreview() {
    if (!startTimeSlider || !endTimeSlider) return;
    
    const startSeconds = parseInt(startTimeSlider.value);
    const endSeconds = parseInt(endTimeSlider.value);
    const duration = endSeconds - startSeconds;
    
    if (timeRangePreview) {
      timeRangePreview.textContent = `${secondsToTime(startSeconds)} - ${secondsToTime(endSeconds)}`;
    }
    if (timeRangeDuration) {
      timeRangeDuration.textContent = `(${secondsToTime(duration)})`;
    }
  }

  // Sincronizar slider con input
  function syncSliderToInput(slider, input) {
    const seconds = parseInt(slider.value);
    input.value = secondsToTime(seconds);
    updateTimeRangePreview();
  }

  // Sincronizar input con slider
  function syncInputToSlider(input, slider, isEnd = false) {
    const seconds = timeToSeconds(input.value);
    if (isNaN(seconds) || seconds < 0) return;
    
    const maxSeconds = videoDurationSeconds;
    let clampedSeconds = Math.min(Math.max(0, seconds), maxSeconds);
    
    if (isEnd) {
      // Para el slider de fin, asegurar que sea mayor que el inicio
      const startSeconds = parseInt(startTimeSlider.value);
      clampedSeconds = Math.max(clampedSeconds, startSeconds + 1);
    } else {
      // Para el slider de inicio, asegurar que sea menor que el fin
      const endSeconds = parseInt(endTimeSlider.value);
      clampedSeconds = Math.min(clampedSeconds, endSeconds - 1);
    }
    
    slider.value = clampedSeconds;
    input.value = secondsToTime(clampedSeconds);
    updateTimeRangePreview();
  }

  // Event listeners para el selector de tiempo
  if (enableTimeRange) {
    enableTimeRange.addEventListener('change', function() {
      if (timeRangeControls) {
        timeRangeControls.style.display = this.checked ? 'block' : 'none';
      }
    });
  }

  if (startTimeSlider) {
    startTimeSlider.addEventListener('input', function() {
      syncSliderToInput(this, startTimeInput);
      // Asegurar que el fin sea mayor que el inicio
      const startSeconds = parseInt(this.value);
      if (endTimeSlider && parseInt(endTimeSlider.value) <= startSeconds) {
        endTimeSlider.value = Math.min(startSeconds + 1, videoDurationSeconds);
        syncSliderToInput(endTimeSlider, endTimeInput);
      }
    });
  }

  if (endTimeSlider) {
    endTimeSlider.addEventListener('input', function() {
      syncSliderToInput(this, endTimeInput);
      // Asegurar que el inicio sea menor que el fin
      const endSeconds = parseInt(this.value);
      if (startTimeSlider && parseInt(startTimeSlider.value) >= endSeconds) {
        startTimeSlider.value = Math.max(0, endSeconds - 1);
        syncSliderToInput(startTimeSlider, startTimeInput);
      }
    });
  }

  if (startTimeInput) {
    startTimeInput.addEventListener('blur', function() {
      syncInputToSlider(this, startTimeSlider, false);
    });
    startTimeInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        syncInputToSlider(this, startTimeSlider, false);
      }
    });
  }

  if (endTimeInput) {
    endTimeInput.addEventListener('blur', function() {
      syncInputToSlider(this, endTimeSlider, true);
    });
    endTimeInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        syncInputToSlider(this, endTimeSlider, true);
      }
    });
  }

  // Detectar plataforma y obtener formatos autom谩ticamente al pegar o escribir URL
  urlInput.addEventListener('input', function() {
    const url = urlInput.value.trim();
    
    // Limpiar timeout anterior
    if (detectTimeout) {
      clearTimeout(detectTimeout);
    }
    
    // Si la URL est谩 vac铆a, ocultar badges y restaurar selector por defecto
    if (!url) {
      hidePlatformBadges();
      // Ocultar selector de tiempo
      if (timeRangeSelector) {
        timeRangeSelector.style.display = 'none';
      }
      if (enableTimeRange) {
        enableTimeRange.checked = false;
      }
      if (timeRangeControls) {
        timeRangeControls.style.display = 'none';
      }
      // Restaurar selector por defecto
      const qualitySelect = document.getElementById('quality');
      if (qualitySelect) {
        qualitySelect.innerHTML = `
          <option value="best">Mejor disponible</option>
          <option value="audio">Solo audio (MP3)</option>
        `;
      }
      return;
    }
    
    // Esperar un momento despu茅s de que el usuario termine de escribir/pegar
    detectTimeout = setTimeout(async () => {
      if (url && url.startsWith('http')) {
        try {
          // Obtener plataforma y formatos en paralelo
          const [platformResponse, formatsResponse] = await Promise.all([
            fetch('/api/detect-platform', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ url: url })
            }),
            fetch('/api/formats/list', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ url: url })
            })
          ]);
          
          // Mostrar plataforma
          if (platformResponse.ok) {
            const platform = await platformResponse.json();
            showPlatformBadge(platform.icon, platform.name);
          } else {
            hidePlatformBadges();
          }
          
          // Actualizar selector de calidad con formatos disponibles
          if (formatsResponse.ok) {
            const formatsData = await formatsResponse.json();
            if (formatsData.formats && formatsData.formats.length > 0) {
              updateQualitySelector(formatsData.formats);
            }
            // Actualizar selector de tiempo con duraci贸n del video
            if (formatsData.duration !== undefined) {
              updateTimeRangeSelector(formatsData.duration, formatsData.duration_formatted);
            }
          }
        } catch (error) {
          // Silenciar errores de detecci贸n
          hidePlatformBadges();
        }
      } else {
        hidePlatformBadges();
      }
    }, 800); // Esperar 800ms despu茅s de que el usuario deje de escribir (m谩s tiempo para obtener formatos)
  });

  form.addEventListener('submit', async function(e) {
    e.preventDefault();
    
    const url = document.getElementById('url').value.trim();
    const quality = document.getElementById('quality').value;
    
    if (!url) {
      alert('Por favor, ingresa una URL');
      return;
    }

    // Obtener tiempos de inicio y fin si el recorte est谩 habilitado
    let startTime = null;
    let endTime = null;
    
    if (enableTimeRange && enableTimeRange.checked && startTimeSlider && endTimeSlider) {
      startTime = parseInt(startTimeSlider.value);
      endTime = parseInt(endTimeSlider.value);
      
      // Validar que los tiempos sean v谩lidos
      if (startTime >= endTime || startTime < 0 || endTime > videoDurationSeconds) {
        alert('Por favor, selecciona un rango de tiempo v谩lido');
        return;
      }
    }

    // Ocultar resultados anteriores
    downloadResult.style.display = 'none';
    downloadResult.innerHTML = '';
    
    // Deshabilitar bot贸n y mostrar estado de carga
    downloadBtn.disabled = true;
    downloadBtnText.textContent = 'Iniciando...';
    
    // Mostrar barra de progreso
    progressContainer.style.display = 'block';
    progressBarFill.style.width = '0%';
    progressPercent.textContent = '0%';
    progressMessage.textContent = 'Iniciando descarga...';

    try {
      // Iniciar descarga
      const response = await fetch('/api/download/start', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
          url, 
          quality,
          start_time: startTime,
          end_time: endTime
        })
      });

      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.error || 'Error al iniciar la descarga');
      }

      currentTaskId = data.task_id;
      
      // Iniciar polling del progreso
      progressInterval = setInterval(checkProgress, 500);
      checkProgress(); // Primera verificaci贸n inmediata
      
    } catch (error) {
      console.error('Error al iniciar descarga:', error);
      progressMessage.textContent = 'Error: ' + error.message;
      progressBarFill.style.backgroundColor = '#ff4444';
      
      // Rehabilitar bot贸n
      downloadBtn.disabled = false;
      downloadBtnText.textContent = 'Descargar';
      
      // Mostrar error en el resultado
      showDownloadResult({ error: error.message });
      
      setTimeout(() => {
        progressContainer.style.display = 'none';
      }, 5000);
    }
  });

  async function checkProgress() {
    if (!currentTaskId) return;

    try {
      const response = await fetch(`/api/download/progress/${currentTaskId}`);
      const progress = await response.json();

      if (!response.ok) {
        throw new Error(progress.error || 'Error al obtener progreso');
      }

      // Actualizar barra de progreso
      const percent = Math.round(progress.percent || 0);
      progressBarFill.style.width = percent + '%';
      progressPercent.textContent = percent + '%';
      progressMessage.textContent = progress.message || 'Descargando...';

      // Manejar diferentes estados
      if (progress.status === 'starting') {
        progressBarFill.style.backgroundColor = '#4CAF50';
      } else if (progress.status === 'downloading') {
        progressBarFill.style.backgroundColor = '#2196F3';
      } else if (progress.status === 'processing') {
        progressBarFill.style.backgroundColor = '#FF9800';
      }

      // Manejar estados finales
      if (progress.status === 'completed') {
        clearInterval(progressInterval);
        progressBarFill.style.width = '100%';
        progressPercent.textContent = '100%';
        progressMessage.textContent = 'Descarga completada';
        progressBarFill.style.backgroundColor = '#4CAF50';
        
        // Rehabilitar bot贸n
        downloadBtn.disabled = false;
        downloadBtnText.textContent = 'Descargar';
        
        // Mostrar resultado
        if (progress.result) {
          showDownloadResult(progress.result);
        }
        
        // Ocultar progreso despu茅s de 2 segundos
        setTimeout(() => {
          progressContainer.style.display = 'none';
        }, 2000);
      } else if (progress.status === 'error') {
        clearInterval(progressInterval);
        progressMessage.textContent = 'Error: ' + progress.message;
        progressBarFill.style.backgroundColor = '#ff4444';
        
        // Rehabilitar bot贸n
        downloadBtn.disabled = false;
        downloadBtnText.textContent = 'Descargar';
        
        // Mostrar error en resultado tambi茅n
        if (progress.result && progress.result.error) {
          showDownloadResult(progress.result);
        }
        
        setTimeout(() => {
          progressContainer.style.display = 'none';
        }, 5000);
      }
    } catch (error) {
      console.error('Error checking progress:', error);
      // Si hay un error al obtener el progreso, detener el polling
      if (progressInterval) {
        clearInterval(progressInterval);
        progressInterval = null;
      }
      progressMessage.textContent = 'Error al obtener progreso: ' + error.message;
      progressBarFill.style.backgroundColor = '#ff4444';
      
      // Rehabilitar bot贸n
      downloadBtn.disabled = false;
      downloadBtnText.textContent = 'Descargar';
    }
  }

  function showDownloadResult(result) {
    let html = '';
    
    if (result.error) {
      html = `
        <div class="message error-message">
          <span>Error: ${result.error}</span>
        </div>
      `;
    } else {
      html = `
        <div class="download-success">
          <div class="success-card">
            <h3 class="success-title">Descarga completada</h3>
            <p class="success-filename">${result.filename || 'Archivo descargado'}</p>
            <a href="/downloads/${result.filename}" class="download-link">
              Descargar archivo
            </a>
          </div>
        </div>
      `;
      
      // Mostrar informaci贸n del video si est谩 disponible
      if (result.video_info) {
        const videoInfo = result.video_info;
        let videoHtml = `
          <div class="video-preview">
            <div class="video-info-card">
        `;
        
        if (videoInfo.thumbnail) {
          videoHtml += `
            <div class="video-thumbnail">
              <img src="${videoInfo.thumbnail}" alt="Thumbnail" loading="lazy">
            </div>
          `;
        }
        
        videoHtml += `
          <div class="video-details">
            <h3 class="video-title">${videoInfo.title || 'Sin t铆tulo'}</h3>
        `;
        
        if (videoInfo.uploader) {
          videoHtml += `<p class="video-uploader">${videoInfo.uploader}</p>`;
        }
        
        if (videoInfo.duration_formatted) {
          videoHtml += `<p class="video-duration">${videoInfo.duration_formatted}</p>`;
        }
        
        videoHtml += `
          </div>
        </div>
      </div>
        `;
        
        html = videoHtml + html;
      }
      
      // Mostrar badge de plataforma si est谩 disponible
      if (result.platform) {
        html = `
          <div class="platform-detected">
            <div class="platform-badge">
              <span class="platform-icon">${result.platform.icon}</span>
              <span class="platform-name">${result.platform.name}</span>
            </div>
          </div>
        ` + html;
      }
    }
    
    downloadResult.innerHTML = html;
    downloadResult.style.display = 'block';
    
    // Actualizar lista de descargas despu茅s de completar
    loadDownloadsList();
  }

  // Cargar lista de descargas
  async function loadDownloadsList() {
    const downloadsList = document.getElementById('downloads-list');
    
    try {
      const response = await fetch('/api/downloads/list');
      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.error || 'Error al cargar descargas');
      }
      
      if (data.downloads && data.downloads.length > 0) {
        let html = '';
        data.downloads.forEach(download => {
          html += `
            <div class="download-item">
              <div class="download-item-info">
                <h4 class="download-item-name">${download.filename}</h4>
                <div class="download-item-meta">
                  <span class="download-item-size">${download.size_mb} MB</span>
                  <span class="download-item-date">${download.modified_readable}</span>
                </div>
              </div>
              <a href="${download.url}" class="download-item-link" download>
                猬锔 Descargar
              </a>
            </div>
          `;
        });
        downloadsList.innerHTML = html;
      } else {
        downloadsList.innerHTML = '<p class="empty-message">No hay descargas disponibles</p>';
      }
    } catch (error) {
      downloadsList.innerHTML = `<p class="error-message">Error: ${error.message}</p>`;
    }
  }

  // Bot贸n de actualizar
  document.getElementById('refresh-downloads').addEventListener('click', loadDownloadsList);
  
  // Cargar lista al iniciar
  loadDownloadsList();
});
</script>
{% endblock %}

